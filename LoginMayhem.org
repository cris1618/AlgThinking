#+TITLE: Login Mayhem
#+AUTHOR: Cristian Del Gobbo (pledged)
#+SUBTITLE: Problem taken from the book "Algorithmic Thinking" by Daniel Zingaro
#+STARTUP: overview hideblocks indent
#+PROPERTY: header-args:C :main yes :includes <stdio.h> :results output

** Solution 1: Looking at all Passwords
   #+begin_src C
     #define MAX_USERS 100000
     #define MAX_PASSWORD 10

     int main(){
       static char users[MAX_USERS][MAX_PASSWORD + 1];
       int num_ops, op, op_type, total, j;

       char password[MAX_PASSWORD + 1];

       int num_users = 0;
       scanf("%d", &num_ops);

       for(op = 0; op < num_ops; op++){
	 scanf("%d%s", &op_type, password);

	 if(op_type == 1){
	   strcpy(users[num_users], password);
	   num_users++;
	 }else{
	   total = 0;

	   for(j=0; j<num_users; j++){
	     if(strstr(users[j], password)){
	       total++;
	       printf("%d\n", total);
	     }
	   } 
	 }


       }

       return 0;
     }
   
   #+end_src 

   #+RESULTS:
** Solution 2: Using a Hash Table
#+begin_src C
  #include <string.h>
  #include <stdlib.h>

  // Define the function one-at-a-time (oaat)
  #define hashsize(n)  ((unsigned long)1 << (n))
  #define hashmask(n)  ((hashsize(n)) - 1)

  unsigned long oaat(char *key, unsigned long len, unsigned long bits) {
    unsigned long hash, i;

    for(hash = 0, i = 0; i < len; i++) {
      hash += key[i];
      hash += (hash << 10);
      hash ^= (hash >> 6);
    }
    hash += (hash << 3);
    hash ^= (hash >> 11);
    hash += (hash << 15);

    return (hash & hashmask(bits));  
  }
  #define MAX_PASSWORD 10

  typedef struct password_node{
    char password[MAX_PASSWORD + 1];
    int total;
    struct password_node *next;
  } password_node;

  // Write a helper function to search the Hash Table for a given password
  #define NUM_BITS 20

  password_node *in_hash_table(password_node *hash_table[], char *find){
    unsigned password_code;
    password_node *password_ptr;
    password_code = oaat(find, strlen(find), NUM_BITS);
    password_ptr = hash_table[password_code];
    while(password_ptr){
      if(strcmp(password_ptr -> password, find) == 0){
        return password_ptr;
        password_ptr = password_ptr -> next;
      }

    }
    return NULL;

  }
  void add_to_hash_table(password_node *hash_table[], char *find){
    unsigned password_code;
    password_node *password_ptr;

    password_ptr = in_hash_table(hash_table, find);
    if(!password_ptr){
      password_code = oaat(find, strlen(find), NUM_BITS);
      password_ptr = malloc(sizeof(password_node));
      if(password_ptr == NULL){
        fprintf(stderr, "Malloc error\n");
        exit(1);
      }
      strcpy(password_ptr -> password, find);
      password_ptr->total = 0;
      password_ptr -> next = hash_table[password_code];
      hash_table[password_code] = password_ptr;
    }
    password_ptr->total++;
  }

  int already_added(char all_substrings[][MAX_PASSWORD + 1], int total_substrings, char *find){
    int i;
    for(i=0; i < total_substrings; i++){
      if(strcmp(all_substrings[i], find) == 0){
        return 1;
      }

    }
    return 0;

  }

  // Write the main function and test the code
  int main(){
    static password_node *hash_table[1 << NUM_BITS] = {NULL};
    int num_ops, op, op_type, i, j;

    char password[MAX_PASSWORD + 1], substring[MAX_PASSWORD + 1];
    password_node *password_ptr;

    int total_substrings;
    char all_substrings[MAX_PASSWORD * MAX_PASSWORD][MAX_PASSWORD + 1];

    scanf("%d", &num_ops);
    for(op=0; op < num_ops; op++){
      scanf("%d%s", &op_type, password);

      if(op_type == 1){
        total_substrings = 0;
        for(i = 0; i< strlen(password); i++){
          for(j = i; j< strlen(password); j++){
            strncpy(substring, &password[i], j-i+1);
            substring[j-i +1] = '\0';

            if(!already_added(all_substrings, total_substrings, substring)){
              add_to_hash_table(hash_table, substring);
              strcpy(all_substrings[total_substrings], substring);
              total_substrings++;
            }
          }
        }
      }else{
        password_ptr = in_hash_table(hash_table, password);
        if(!password_ptr){
          printf("0\n");
        }else{
          printf("%d\n", password_ptr -> total); 
        }
      }

    }

    return 0;
  }
#+end_src

#+RESULTS:
