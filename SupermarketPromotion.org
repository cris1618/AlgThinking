#+TITLE: Supermarket Promotion
#+AUTHOR: Cristian Del Gobbo (pledged)
#+SUBTITLE: Problem taken from the book "Algorithmic Thinking" by Daniel Zingaro
#+STARTUP: overview hideblocks indent
#+PROPERTY: header-args:C :main yes :includes <stdio.h> <stdlib.h> :results output :noweb yes

* Solution 1: Max and Min in an arrays
#+begin_src bash :results output
  echo "2" > recarr
  echo "16 6 63 16 82 25 2 43 5 17 10 56 85 38 15 32 91" >> recarr
  echo "1 57" >> recarr
  cat recarr
#+end_src

#+RESULTS:
: 2
: 16 6 63 16 82 25 2 43 5 17 10 56 85 38 15 32 91
: 1 57

#+begin_src C :cmdline < recarr
  #define MAX_RECEIPTS 1000000
  #define MAX_COST 1000000

  typedef struct receipt{
    int cost;
    int used;
  } receipt;

  int extract_max(receipt receipts[], int num_receipts){
    int max, max_index, i;
    max = -1;
    for(i=0; i<num_receipts; i++)
      if(!receipts[i].used && receipts[i].cost > max){
        max_index = i;
        max = receipts[i].cost;
      }
    receipts[max_index].used = 1;
    return max;
  }

  int extract_min(receipt receipts[], int num_receipts){
    int min, min_index, i;
    min = MAX_COST + 1;
    for(i=0; i<num_receipts; i++)
      if(!receipts[i].used && receipts[i].cost < min){
        min_index = i;
        min = receipts[i].cost;
      }
    receipts[min_index].used = 1;
    return min;
  }

  int main(){
    static struct receipt receipts[MAX_RECEIPTS];
    int num_days, num_receipts_today;
    int num_receipts = 0;
    long long total_prizes = 0;
    int i, j, max, min;
    scanf("%d", &num_days);
    for(i=0; i<num_days; i++){
      scanf("%d", &num_receipts_today);
      for(j=0; j<num_receipts_today; j++){
        scanf("%d", &receipts[num_receipts].cost);
        receipts[num_receipts].used = 0;
        num_receipts++;
      }
      max = extract_max(receipts, num_receipts);
      min = extract_min(receipts, num_receipts);
      total_prizes += max-min;
    }
    printf("%lld\n", total_prizes);
    return 0;
  }

#+end_src

#+RESULTS:
: 169

** Implementing a Max-Heap
#+begin_src C
  typedef struct heap_element{
    int receipt_index;
    int cost;
  }heap_element;

  void max_heap_insert(heap_element heap[], int* num_heap, int receipt_index, int cost){
    int i;
    heap_element temp;
    (*num_heap)++;
    heap[*num_heap] = (heap_element){receipt_index, cost};
    i = *num_heap;
    while(i > 1 && heap[i].cost > heap[i/2].cost){
      temp = heap[i];
      heap[i] = heap[i/2];
      heap[i/2] = temp;
      i = i/2;
    }
  }

  // Extract from max-heap
  heap_element max_heap_extract(heap_element heap[], int* num_heap){
    heap_element remove, temp;
    int i, child;

    remove = heap[1];
    heap[1] = heap[*num_heap];
    (*num_heap)--;
    i = 1;
    while(i*2 <= *num_heap){
      child = i*2;
      if(child < *num_heap && heap[child + 1].cost > heap[child].cost)
        child++;
      if(heap[child].cost > heap[i].cost){
        temp = heap[i];
        heap[i] = heap[child];
        heap[child] = temp;
        i = child;
      } else
        break;
    }
    return remove;
  }
#+end_src

#+RESULTS:
